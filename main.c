#define F_CPU 16000000UL

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <util/delay.h>
#include "lol.h"
#include "game.h"
#include "spriteDatabase.h"

unsigned int randSeed = 0;

#ifndef _BV
#define _BV(bit) (1 << (bit))
#endif

#define CS_LOW PORTB &= ~(1 << PORTB2)
#define CS_HIGH PORTB |= (1 << PORTB2)

#define RESET_LOW PORTB &= ~(1 << PORTB1)
#define RESET_HIGH PORTB |= (1 << PORTB1)

#define LED_OFF PORTC |= (1 << PORTC5)
#define LED_ON PORTC &= ~(1 << PORTC5)

#define COMMAND_LOW PORTC &= ~(1 << PORTC0)
#define COMMAND_HIGH PORTC |= (1 << PORTC0)

#define BAUD 9600 // define baud
#define BAUDRATE ((F_CPU)/(BAUD*16UL)-1) // set baud rate value for UBRR

uint8_t displayBuffer[LCDWIDTH * LCDHEIGHT / 8] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFC, 0xFE, 0xFF, 0xFC, 0xE0,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8,
	0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80, 0xC0,
	0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x87, 0x8F, 0x9F,
	0x9F, 0xFF, 0xFF, 0xFF, 0xC1, 0xC0, 0xE0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFC, 0xFC, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFC, 0xFC, 0xF8, 0xF8,
	0xF0, 0xE0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0,
	0xF1, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x1F, 0x0F, 0x0F, 0x87,
	0xE7, 0xFF, 0xFF, 0xFF, 0x1F, 0x1F, 0x3F, 0xF9, 0xF8, 0xF8, 0xF8, 0xF8,
	0xF8, 0xF8, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x7F, 0x3F, 0x0F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFE, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x7E, 0x3F, 0x3F, 0x0F,
	0x1F, 0xFF, 0xFF, 0xFF, 0xFC, 0xF0, 0xE0, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFC, 0xF0, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x03, 0x0F, 0x1F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF,
	0x7F, 0x7F, 0x1F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

void uart_init (void)
{
	UBRR0H = (BAUDRATE>>8); // shift the register right by 8 bits
	UBRR0L = BAUDRATE; // set baud rate
	UCSR0B|= (1<<TXEN0)|(1<<RXEN0); // enable receiver and transmitter
	UCSR0C = (3<<UCSZ00);
}

int uart_transmit(char data  )
{
	while (!( UCSR0A & (1<<UDRE0))); // wait while register is free
	UDR0 = data; // load data in the register
	return 0;
}

unsigned char uart_receive( void )
{
	while ( !(UCSR0A & (1<<RXC0)) );
	return UDR0;
}

char defaultSpriteData[8] = {0b11000000,0b11000000,0b11000000,0b00110000,0b00110000,0b00001100,0b00000011,0};
int spriteHeight = 8;
int spriteWidth = 7;

char andMasks[10] = {0,1,0b00000011,0b00000111,0b00001111,0b00011111,0b00111111,0b01111111,0b11111111,0b11111111};

// right align.
void drawDigits(int x, int y, int input)
{
	int tempVal = input;
	int nextByte = 0;
	int byteCounter = 0;
	if(input == 0)
	{
		// special case - while loop never triggers for 0
		drawSprite(x,y,8,4,SPRITE_LETTER);
		return;
	}
	while(tempVal != 0)
	{
		byteCounter += 1;
		nextByte = tempVal % 10;
		drawSprite(x - (byteCounter * 5),y,8,4,SPRITE_LETTER + (nextByte * 4));
		tempVal = tempVal / 10;
	}
}

void drawSprite(int _x, int _y, int spriteHeight, int spriteWidth, const char *spriteBlock)
{
	if(spriteHeight > 8)
	{
		return;
	}
	int x = LCDWIDTH - 1 - _x;
	int y = LCDHEIGHT - 1 - _y;
	int spriteCol = 0;
	char upperByte = 0;
	char lowerByte = 0;
	for(;spriteCol < spriteWidth;spriteCol++)
	{
		int ySplitPos = (8 - (y % 8));
		int ySplitPos2 = y % 8;
		upperByte = (pgm_read_byte(spriteBlock + spriteCol) & andMasks[ySplitPos]) << ySplitPos2;
		lowerByte = (pgm_read_byte(spriteBlock + spriteCol) & (0xFF ^ andMasks[ySplitPos])) >> (8 - ySplitPos2);
		// lowerByte = spriteBlock[spriteCol] & andMasks[((y % 8))] )  << ;
		displayBuffer[x + spriteCol + (y / 8) * LCDWIDTH] |= upperByte;
		if(ySplitPos2 != 0)
		{
			displayBuffer[x + spriteCol + ((y / 8) + 1) * LCDWIDTH] |= lowerByte;
		}
	}
}

void drawPixel(int _x, int _y,int onoff)
{

	int x = LCDWIDTH - 1 - _x;
	int y = LCDHEIGHT - 1 - _y;
	
	  if (onoff == 1)
	  {
		  displayBuffer[x + (y / 8) * LCDWIDTH] |= _BV(y % 8);
	  }
	  else
	  {
		  displayBuffer[x + (y / 8) * LCDWIDTH] &= ~_BV(y % 8);
	  }
	return;
}

void spi_init_master (void)
{
	DDRB |= (1<<5)|(1<<3)|(1<<2)|(1 << 1);
	SPCR=(1<<SPE)|(1<<MSTR)|(1 << SPR0);// |(1<<SPR0);// |(1<<SPR0);
	PORTB |= (1<<2);
}

unsigned char spiTx(unsigned char data)
{
	SPDR = data;
	while(!(SPSR & (1<<SPIF) ));
	return(SPDR);
}

void command(uint8_t c) {
	
	COMMAND_LOW;
	CS_LOW;
	spiTx(c);
	CS_HIGH;
}

uint8_t _bias = 0;
uint8_t _contrast = 0;

void setBias(uint8_t val) {
	if (val > 0x07) {
		val = 0x07;
	}
	_bias = val;
	command(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION);
	command(PCD8544_SETBIAS | val);
	command(PCD8544_FUNCTIONSET);
}

void setContrast(uint8_t val) {
	if (val > 0x7f) {
		val = 0x7f;
	}
	_contrast = val;
	command(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION);
	command(PCD8544_SETVOP | val);
	command(PCD8544_FUNCTIONSET);
}

void display(void) {
	uint8_t col, maxcol, p;
	for (p = 0; p < 6; p++) {

		command(PCD8544_SETYADDR | p);
		col = 0;
		maxcol = LCDWIDTH - 1;
		command(PCD8544_SETXADDR | col);
		
		COMMAND_HIGH;
		CS_LOW;
		for (; col <= maxcol; col++) 
		{
			spiTx(displayBuffer[(LCDWIDTH * p) + col]);
		}
		CS_HIGH;
		
		command(PCD8544_SETYADDR);
	}
}

void render(GameState *gc)
{
	memset(displayBuffer,0,sizeof(displayBuffer));
	int playerX = gc->playerX;
	int playerY = gc->playerY;
	drawSprite(playerX,playerY, SPRITE_PLAYER_H, SPRITE_PLAYER_W, SPRITE_PLAYER);
	// drawSprite(15,15,SPRITE_APPLE_H,SPRITE_APPLE_W,SPRITE_APPLE);
	int i = 0;
	for(i = 0;i < MAX_SPRITES;i++)
	{
		if(gc->spriteIndex[i] == ITEM_APPLE)
		{
			drawSprite(gc->spriteX[i],gc->spriteY[i],SPRITE_APPLE_H,SPRITE_APPLE_W,SPRITE_APPLE);
		}
	}
	drawDigits(80,10,gc->score);
}

int main(void)
{
	uart_init();
	FILE mystdio = FDEV_SETUP_STREAM(uart_transmit, uart_receive, _FDEV_SETUP_RW);
	
	stdout = &mystdio;
	stdin = &mystdio;
	
	GameState gc;
	
	DDRC |= (1 << PORTC5) | (1 << PORTC0); // setup led
	DDRD &= ~((1 << PORTD2) | (1 << PORTD3) | (1 << PORTD7) | (1 << PORTD6) | (1 << PORTD5) | (1 << PORTD4));       // GPIO's
	PORTD |= (1 << PORTD2) | (1 << PORTD3) | (1 << PORTD7) | (1 << PORTD6) | (1 << PORTD5) | (1 << PORTD4) ;         // internal pullups
	
	
		int i = 0;
		for(;i < 3;i++)
		{
			LED_ON;
			_delay_ms(200);
			LED_OFF;
			_delay_ms(200);
		}
	spi_init_master();
	RESET_LOW;
	_delay_ms(100);
	RESET_HIGH;
	
	memset(displayBuffer,0,sizeof(displayBuffer));
	
	command(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION);
	command(PCD8544_SETBIAS | 0x4);
	setContrast(0x40);
	command(PCD8544_FUNCTIONSET);
	command(PCD8544_DISPLAYCONTROL | PCD8544_DISPLAYNORMAL);
	printf("L\n");
	LED_ON;
	display();
	
	uint32_t tickCount = 0;
	while(1)
	{
		char input = PIND;
		randSeed += 1;
		if((input & DETECT_CHANGE) != (DETECT_CHANGE))
		{
			goto seedRNG;
		}
	}
	
	seedRNG:;
	srand(randSeed);
	printf("R\n");
	initGameState(&gc);
	printf("G\n");
	
    while(1)
    {
		if(tickCount == 0x20000)
		{
			tickCount = 0;
			if(updateGame(&gc) == 1)
			{
				render(&gc);
				display();
			}
		}
		tickCount += 1;
    }
}
